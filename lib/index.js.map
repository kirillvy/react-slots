{"version":3,"sources":["webpack://slottr/webpack/universalModuleDefinition","webpack://slottr/webpack/bootstrap","webpack://slottr/external \"react\"","webpack://slottr/./src/utils/useScope.tsx","webpack://slottr/./src/utils/createSlot.tsx","webpack://slottr/./src/ConditionalSlot/index.tsx","webpack://slottr/./src/index.tsx","webpack://slottr/./src/ConditionalSlot/createConditionalSlot.tsx","webpack://slottr/./src/FilterSlot/index.tsx","webpack://slottr/./src/CompositionSlot/index.tsx"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ScopeMap","Map","childrenProp","super","lastIndex","scopeChildren","this","children","injectElement","child","childType","isValidElement","undefined","type","obj","displaySymbol","displayName","resultGet","index","pushLastIndex","set","push","includes","arr","every","evalSlot","includeSlots","reduce","filterSlot","excludeSlots","all","prev","vals","reduceConds","forEach","val","cond","nonSlotted","exclude","el","isConditionsComponent","slot","test","objConditions","filter","elem","props","some","has","mapArr","Array","length","Children","els","sort","a","b","map","entity","prevV","default","scope","injectSlot","Element","slotProps","defaultElement","defaultProps","passedProps","withContext","childIs","Context","Provider","contextChildren","React","cloneElement","ContextProvider","childProps","SlottableElement","Fragment","renderInParam","ElDefault","createElement","RenderedIn","renderAs","renderIn","renderInProps","createSlot","SlottedElement","createContext","Before","After","Slot","multiple","fallback","fallbackProps","noHeaders","childrenObj","res","headersList","footersList","headers","footers","element","childObj","result","SlotFactory","SubSlot","useContext","SubSlotFactory","contextTypes","createLayeredSlot","Consumer","elDisplay","IF","ELSEIF","ELSE","slotEvalIf","excludes","condition","include","conditional","Boolean","createDefaultConditionalSlot","typeSymbol","parent","createdElement","ConditionalSlot","elProps","newProps","scopeObj","evalResult","onIf","pastIf","cur","valid","If","ElseIf","Else","mapElements","setTimeout","ConditionalSlotElement","createConditionalElement","useScope","createConditionalSlot","FilterSlot","CompositionSlot","Conditional","ConditionalSubSlotFactory","createFilterSlot","grouped","childrenObject","x","filterElement","checkSlot","included","isSlotted","childrenCount","count","FilterSlotFactory","DefaultFilterSlot","CompositionSlotComponent","isArray","El","slotted","CompositionSlotFactory","createCompositionSlot"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"slottr\", [\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"slottr\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"slottr\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import React from 'react';\nimport { ISortChildrenEl, ISlotComponent } from './createSlot';\n\n/**\n * Indexes React children for faster access by Slot components\n * @param scope - react children, in any format\n */\n\nexport interface IConditionsComponent {\n  /**\n   * Slottable component for filtering\n   */\n  slot: ISlotComponent<any>;\n  /**\n   * Slottable component test\n   */\n  test: <T = any>(props: T) => boolean;\n}\n\nexport type TConditionalSlot = ISlotComponent<any> | IConditionsComponent;\n\n/**\n * Scope object. Slottable elements are tracked as Element.DisplaySymbol\n * Custom components as Element.DisplayName.\n */\nexport class ScopeMap extends Map<symbol | string, ISortChildrenEl[]> {\n  public static isConditionsComponent = (\n    entity: ISlotComponent<any> | IConditionsComponent,\n    ): entity is IConditionsComponent => {\n    return (entity as IConditionsComponent).test !== undefined;\n  }\n  /**\n   * Reduces conditions to an object.\n   */\n  public static reduceConds = (arr: TConditionalSlot[]) => arr.reduce((prevV, val) => {\n    const key = ScopeMap.isConditionsComponent(val) ? val.slot.displaySymbol : val.displaySymbol as any;\n    prevV[key] = val;\n    return prevV;\n  }, {} as { [x: string]: TConditionalSlot })\n\n  /**\n   * Sorts elements by order of appearance\n   * @param els children object to sort into children\n   */\n  public static sortElements(els: ISortChildrenEl[]): JSX.Element[] {\n    return els.sort((a, b) => a.index - b.index).map((el) => el.child);\n  }\n  /**\n   * Returns grouped elements, by order of appearance\n   * @param els children object to sort into children\n   */\n  public static mapElements(els: ISortChildrenEl[]): JSX.Element[] {\n    return els.map((el) => el.child);\n  }\n  private lastIndex = -1;\n  private children: any;\n  constructor(childrenProp?: any) {\n    super();\n    if (!childrenProp) {\n      return;\n    }\n    const mapArr = (arr: any[]) => arr.reduce((prev, el) => {\n        if (el instanceof Array && el.length) {\n          prev.push(...mapArr(el));\n        } else {\n          prev.push(el);\n        }\n        return prev;\n      },\n      [] as any[]);\n    this.children = mapArr([childrenProp]);\n    React.Children.forEach(childrenProp, this.injectElement);\n  }\n  /**\n   * Injects element into the scope\n   * @param child JSX element to inject\n   */\n  public scopeChildren = () => this.children;\n  /**\n   * inject JSX element into scope object\n   */\n  public injectElement = (child: JSX.Element) => {\n    let childType = 'string';\n    if (React.isValidElement(child) && child.type !== undefined) {\n      const obj: any = child.type;\n      if (obj.hasOwnProperty('displaySymbol')) {\n        childType = obj.displaySymbol;\n      } else if (obj.hasOwnProperty('displayName')) {\n        childType = obj.displayName || 'string';\n      } else {\n        childType = obj;\n      }\n    }\n    const resultGet = this.get(childType);\n    const index = this.pushLastIndex();\n    if (resultGet === undefined) {\n      this.set(childType, [{index, child}]);\n    } else {\n      resultGet.push({index, child});\n      this.set(childType, resultGet);\n    }\n  }\n  /**\n   * Tests whether object includes all conditional slots\n   * @param arr conditional slots for inclusion\n   */\n  public includes = (...arr: TConditionalSlot[]) => {\n    return arr.every(this.evalSlot(true));\n  }\n  /**\n   * Tests whether object excludes all conditional slots\n   * @param arr conditional slots for exclusion\n   */\n  public excludes(...arr: TConditionalSlot[]) {\n    return !arr.some(this.evalSlot());\n  }\n  /**\n   * Returns array of conditional slots included\n   * @param arr conditional slots for inclusion\n   */\n  public includeSlots = (arr: TConditionalSlot[]) => {\n    return arr.reduce(this.filterSlot(), [] as ISortChildrenEl[]);\n  }\n  /**\n   * Returns array of conditional slots without the excluded ones\n   * @param arr conditional slots for exclusion\n   * @param all include all elements including non-conditional slots\n   */\n  public excludeSlots = (arr: TConditionalSlot[], all?: boolean) => {\n    const prev: ISortChildrenEl[] = [];\n    const vals = ScopeMap.reduceConds(arr);\n    this.forEach((val, key) => {\n      if (typeof key !== 'symbol' && all !== true) {\n        return;\n      }\n      const cond = vals[key as any];\n      if (cond) {\n        this.filterSlot(true)(prev, cond);\n      } else {\n        prev.push(...val);\n      }\n    });\n    return prev;\n  }\n  /**\n   * Returns all non-slot elements in scope\n   */\n  public nonSlotted = () => {\n    const prev: ISortChildrenEl[] = [];\n    this.forEach((val, key) => {\n      if (typeof key !== 'symbol') {\n        prev.push(...val);\n      }\n    });\n    return prev;\n  }\n  /**\n   * controls index on insert\n   */\n  private pushLastIndex = () => {\n    this.lastIndex += 1;\n    return this.lastIndex;\n  }\n  /**\n   * filters slots by params\n   */\n  private filterSlot = (exclude?: boolean) => (prev: ISortChildrenEl[], el: TConditionalSlot) => {\n    if (ScopeMap.isConditionsComponent(el)) {\n      const { slot, test } = el;\n      const objConditions = this.get(slot.displaySymbol);\n      if (objConditions !== undefined) {\n        if (exclude) {\n          prev.push(...objConditions.filter((elem) => !test(elem.child.props)));\n        } else {\n          prev.push(...objConditions.filter((elem) => test(elem.child.props)));\n        }\n      }\n      return prev;\n    }\n    const obj = this.get(el.displaySymbol);\n    if (obj !== undefined && exclude !== true) {\n      prev.push(...obj);\n    }\n    return prev;\n  }\n  /**\n   * evals slots by params\n   */\n  private evalSlot = (includes?: boolean) => (el: TConditionalSlot) => {\n    if (ScopeMap.isConditionsComponent(el)) {\n      const {slot, test} = el;\n      const obj = this.get(slot.displaySymbol);\n      if (includes) {\n        return obj !== undefined && obj.every((elem) => test(elem.child.props)) === true;\n      }\n      return obj !== undefined && obj.some((elem) => test(elem.child.props)) === true;\n    }\n    return this.has(el.displaySymbol);\n  }\n}\n/**\n * Creates scope object for work with slots\n * @param scope - React Children prop\n */\nconst useScope = (scope: any): ScopeMap => {\n  if (scope instanceof ScopeMap) {\n    return scope;\n  }\n  if (scope === undefined || scope.length === 0) {\n    return new ScopeMap();\n  }\n  const result = new ScopeMap(scope);\n  return result;\n};\n\nexport {useScope as default};\n","import * as React from 'react';\n\nimport useScope from './useScope';\n\nexport interface ISlot<T = any> {\n  /**\n   * Default children of element, if any. Otherwise, nothing will be shown.\n   */\n  children?: any;\n  /**\n   * Props that will always be rendered, no matter the scenario\n   */\n  props?: T;\n  /**\n   * default props to use when the default element is rendered\n   */\n  defaultProps?: JSX.IntrinsicAttributes & React.PropsWithChildren<T>;\n  /**\n   * props passed to the element from the component containing the slot\n   */\n  passedProps?: T;\n  /**\n   * Elements or indexed children object passed for filtering\n   */\n  scope?: any;\n  /**\n   * Slottable component test\n   */\n  test?: <S = any>(props: S) => boolean;\n  /**\n   * Display all if multiple slots are passed\n   */\n  multiple?: boolean;\n  /**\n   * Components are composed through their immediate children instead of\n   * children of element\n   */\n  withContext?: boolean;\n  /**\n   * fallback to use if slot is not used\n   */\n  fallback?: any;\n  /**\n   * default props to use with default element\n   */\n  fallbackProps?: JSX.IntrinsicAttributes & React.PropsWithChildren<T>;\n  /**\n   * Designate the children prop as the default element, the fallback element or both\n   */\n  childIs?: 'fallback' | 'default' | 'both';\n  /**\n   * Component is always rendered.\n   */\n  unconditional?: boolean;\n  noHeaders?: boolean;\n}\n\ntype TAny = any;\ntype ElType<T> = ISlotComponent<T> | ISlotComponentExtended<T>;\n\ninterface IRenderAs extends TAny {\n  renderIn?: React.ComponentType<any> | keyof JSX.IntrinsicElements | false;\n  /**\n   * Props passed into next level component\n   */\n  renderInProps?: any;\n  /**\n   * Element injected for rendering instead of default. Any props will have to be compatible.\n   */\n  renderAs?: React.ComponentType<any> | keyof JSX.IntrinsicElements;\n}\n\nexport interface ISubSlot<T> extends Partial<ISlot<T>> {\n  scope: React.Context<any>;\n}\n\nexport interface ISlotElement<T> extends React.FunctionComponent<ISlot<T>> {\n  displaySymbol: symbol;\n}\n\nexport interface ISubSlotElement<T> extends React.FunctionComponent<ISubSlot<T>> {\n  displaySymbol: symbol;\n}\n\nexport interface ISlotComponentBase<T = any> extends React.FunctionComponent<T | IRenderAs | { children?: any }> {\n  Context: React.Context<any>;\n  ContextProvider: React.FunctionComponentElement<React.ProviderProps<any>>;\n  displaySymbol: symbol;\n}\n\nexport interface ISlotComponent<T = any> extends ISlotComponentBase<T> {\n  Slot: ISlotElement<T>;\n  SubSlot: ISubSlotElement<T>;\n  Before: IHeaderFooter;\n  After: IHeaderFooter;\n}\n\nexport interface ISlotElementExtended<T> extends ISlotComponent<ISlot<T>> {\n  displaySymbol: symbol;\n}\n\nexport interface ISlotComponentExtended<T = any> extends ISlotComponentBase<T> {\n  Slot: ISlotElementExtended<T>;\n  SubSlot: ISubSlotElement<T>;\n  Before: IHeaderFooter;\n  After: IHeaderFooter;\n}\n\ninterface IOverloadCreateSlot {\n  (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType<any>,\n    renderIn?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponent;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType<any>,\n    renderIn?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponent<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(\n    Element?: React.ComponentType<any>,\n    renderIn?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponent<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element?: React.ComponentType<any>,\n    renderIn?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element?: React.ComponentType<any>,\n    renderIn?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n}\n\ninterface IOverloadCreateLayeredSlot {\n  (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType<any>,\n    renderIn: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType<any>,\n    renderIn: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(\n    Element: React.ComponentType<any>,\n    renderIn: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element: React.ComponentType<any>,\n    renderIn: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element: React.ComponentType<any>,\n    renderIn: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended<T & Partial<JSX.IntrinsicElements[S]>>;\n}\n\nexport interface IHeaderFooter extends React.FunctionComponent {\n  displaySymbol: symbol;\n  typeSymbol: symbol;\n}\n\nexport interface ISortChildrenEl {\n  index: number;\n  child: JSX.Element;\n}\n\nexport type SlotType<T = {}, S = {}> =\n  T extends {} ? S extends keyof JSX.IntrinsicElements ? T & Partial<JSX.IntrinsicElements[S]> : T :\n  T extends keyof JSX.IntrinsicElements ? S extends {} ? S & Partial<JSX.IntrinsicElements[T]> :\n  Partial<JSX.IntrinsicElements[T]> : any;\n\nexport const injectSlot = <T extends {}>(\n  Element: ElType<T>, slotProps: ISlot<T>,\n) => {\n  return (child: JSX.Element, i?: number) => {\n    const { children: defaultElement, defaultProps, passedProps, withContext, props, childIs } = slotProps;\n    if (withContext === true && defaultElement !== undefined) {\n      if (childIs === 'fallback') {\n        return null;\n      }\n      if (Element.Context.Provider === undefined) {\n        return null;\n      }\n      const contextChildren = React.cloneElement(child, { ...props, ...passedProps });\n      return React.cloneElement(child, { key: i, ...props, ...passedProps }, (\n        React.cloneElement(\n          Element.ContextProvider,\n          {\n            key: i,\n            value: useScope(contextChildren.props.children),\n          },\n          defaultElement,\n        )\n      ));\n    }\n    const childProps: any = child.props;\n    if (child.props === undefined) {\n      return child;\n    }\n    if (childProps.hasOwnProperty('children')) {\n      return React.cloneElement(child, { key: i, ...props, ...passedProps });\n    }\n    return React.cloneElement(child, { key: i, ...props, ...defaultProps, ...passedProps }, defaultElement);\n  };\n};\n\nconst SlotFactory = <T extends {}>(\n  Element: ElType<T>,\n): React.FC<ISlot<T>> => (\n  slotProps,\n  ) => {\n    const { scope, children: defaultElement, multiple = false,\n      fallback, fallbackProps, childIs, test, noHeaders } = slotProps;\n    const childrenObj = useScope(scope);\n    const res = childrenObj.get(Element.displaySymbol);\n    const headersList = childrenObj.get(Element.Before.displaySymbol) || [];\n    const footersList = childrenObj.get(Element.After.displaySymbol) || [];\n    const headers = headersList.map((el) => el.child);\n    const footers = footersList.map((el) => el.child);\n    if (res === undefined) {\n      if ((childIs === 'fallback' || childIs === 'both') && defaultElement !== undefined) {\n        return React.cloneElement(defaultElement, fallbackProps);\n      }\n      if (fallback) {\n        return React.cloneElement(fallback, fallbackProps);\n      }\n      return <>{headers}{footers}</>;\n    }\n    if (multiple === true) {\n      let element = res.reduce((prev, { index, child }) => {\n        const el = injectSlot(Element, slotProps)(child, index);\n        if (el !== null) {\n          prev.push(el);\n        }\n        return prev;\n      }, [] as Array<React.FunctionComponentElement<any>>);\n      if (test !== undefined) {\n        element = element.filter((el) => test(el.props));\n      }\n      return <>{headers}{element}{footers}</>;\n    }\n    const { child: childObj } = res[0];\n    const result = injectSlot(Element, slotProps)(childObj);\n    if (noHeaders && result === null) {\n      return result;\n    }\n    return <>{headers}{result}{footers}</>;\n  };\n\nconst SubSlotFactory = <T extends {}>(Element: ElType<T>): React.FC<ISubSlot<T>> => (\n  { scope: Context, ...props },\n) => {\n  const scope = React.useContext(Context);\n  return Element.Slot({ ...props, scope });\n};\n\nconst SlottableElement: (\n  defaultElement?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n  renderInParam?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n) => React.FC<IRenderAs> = (defaultElement = React.Fragment, renderInParam) => {\n  const ElDefault = React.createElement(defaultElement);\n  const RenderedIn = renderInParam ? React.createElement(renderInParam) : undefined;\n  return (\n    { children, renderAs, renderIn, renderInProps, ...props },\n  ) => {\n    const el = renderAs ? React.createElement(renderAs, props, children) :\n      React.cloneElement(ElDefault, props, children);\n    if (renderIn) {\n      return React.createElement(renderIn, renderInProps, el);\n    }\n    if (RenderedIn && renderIn !== false) {\n      return React.cloneElement(RenderedIn, renderInProps, el);\n    }\n    return el;\n  };\n};\n\n/**\n * Slot constructor\n * @param {React.ComponentType<any>} [Element=React.Fragment] - Element for slotting, default is fragment\n */\nconst createSlot: IOverloadCreateSlot = <T extends {} = {}, S extends {} = {}>(\n  Element: React.ComponentType<any> | keyof JSX.IntrinsicElements = React.Fragment,\n  renderIn?: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n) => {\n  type CurType = SlotType<T, S>;\n  const SlottedElement = SlottableElement(Element, renderIn) as ISlotComponent<CurType>;\n  SlottedElement.Context = React.createContext(null);\n  SlottedElement.ContextProvider = React.createElement(SlottedElement.Context.Provider);\n  SlottedElement.displaySymbol = Symbol();\n  SlottedElement.Before = SlottableElement() as IHeaderFooter;\n  SlottedElement.Before.displaySymbol = Symbol();\n  SlottedElement.After = SlottableElement() as IHeaderFooter;\n  SlottedElement.After.displaySymbol = Symbol();\n  SlottedElement.Slot = SlotFactory<CurType>(SlottedElement) as any;\n  SlottedElement.Slot.displaySymbol = Symbol();\n  SlottedElement.SubSlot = SubSlotFactory<CurType>(SlottedElement) as ISubSlotElement<CurType>;\n  SlottedElement.SubSlot.displaySymbol = Symbol();\n  if (typeof Element !== 'string') {\n    SlottedElement.defaultProps = Element.defaultProps;\n    SlottedElement.contextTypes = Element.contextTypes;\n  }\n  SlottedElement.Slot.displayName = 'Subcomponent.Slot';\n  SlottedElement.displayName = `Subcomponent.SlottedElement`;\n  SlottedElement.SubSlot.displayName = 'Subcomponent.SubSlot';\n  return SlottedElement;\n};\n\nexport const createLayeredSlot: IOverloadCreateLayeredSlot = <T extends {} = {}, S extends {} = {}>(\n  Element: React.ComponentType<any> | keyof JSX.IntrinsicElements = React.Fragment,\n  renderIn: React.ComponentType<any> | keyof JSX.IntrinsicElements,\n) => {\n  type CurType = SlotType<T, S>;\n  const SlottedElement = createSlot(Element, renderIn) as ISlotComponentExtended<CurType>;\n  SlottedElement.Slot = createSlot(SlottedElement.Slot);\n  return SlottedElement;\n};\n\nexport { createSlot as default };\n","import React from 'react';\nimport useScope, { TConditionalSlot, ScopeMap } from '../utils/useScope';\n\nexport interface IConditionalSlotBase {\n  children?: any;\n  /**\n   * Elements or indexed children object passed for filtering\n   */\n  scope?: any;\n  /**\n   * Array of slottable components for filtering out\n   */\n  excludes?: TConditionalSlot[];\n  /**\n   * Array of slottable components whitelisted for not being filtered. Overrides 'exclude'\n   */\n  includes?: TConditionalSlot[];\n  /**\n   * Truthy eval of conditions for implementations.\n   */\n  condition?: any;\n}\n\nexport interface IConditionalSubSlot extends IConditionalSlotBase {\n  scope: React.Context<any>;\n}\n\ninterface IOverloadCreateConditional {\n  (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType<any>,\n  ): IConditionalSlot;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType<any>,\n  ): IConditionalSlot<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(Element: React.ComponentType<any>): IConditionalSlot<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element: React.ComponentType<any>,\n  ): IConditionalSlot<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element: React.ComponentType<any>,\n  ): IConditionalSlot<T & Partial<JSX.IntrinsicElements[S]>>;\n}\n\nexport interface IConditionalSlot<T = {}> extends React.FC<IConditionalSlotBase & T> {\n  If: IConditionalSlot;\n  ElseIf: IConditionalSlot;\n  Else: IConditionalSlot;\n  SubSlot: React.FC<IConditionalSubSlot & T>;\n  displaySymbol: symbol;\n  typeSymbol: symbol;\n}\n\nconst SubSlotFactory = <T extends {}>(\n  Element: IConditionalSlot,\n  ): React.FC<IConditionalSubSlot & T> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element {...props} scope={value}/>}</Context.Consumer>;\n};\n\nconst elDisplay = Symbol();\nconst IF = Symbol();\nconst ELSEIF = Symbol();\nconst ELSE = Symbol();\n\nconst slotEvalIf = ({scope, excludes, includes, condition}: IConditionalSlotBase) => {\n  const childrenObj = useScope(scope);\n  const include = (scope && includes) ? childrenObj.includes(...includes) : true;\n  const exclude = (scope && excludes) ? childrenObj.excludes(...excludes) : true;\n  const conditional = condition !== undefined ? Boolean(condition) : true;\n  return include && exclude && conditional;\n};\n\nexport function createDefaultConditionalSlot(\n  Element: keyof JSX.IntrinsicElements | React.ComponentType<any> = React.Fragment,\n  typeSymbol: symbol = IF,\n  parent?: IConditionalSlot,\n  ): IConditionalSlot {\n  const createdElement = React.createElement(Element);\n  function ConditionalSlot(props: IConditionalSlotBase) {\n    const {children, scope, excludes, includes, condition, ...newProps} = props;\n    const elProps = Element === React.Fragment ? {} : {scope, ...newProps};\n    const scopeObj = useScope(children);\n    const evalResult = parent === undefined ? slotEvalIf({scope, excludes, includes, condition}) : true;\n    const obj = scopeObj.get(ConditionalSlot.displaySymbol);\n    let res: React.ReactNode = null;\n    let [onIf, pastIf] = [false, false];\n    if (obj !== undefined) {\n      for (const i of obj) {\n        const cur: any = i.child;\n        const valid = slotEvalIf(cur.props);\n        if (valid) {\n          res = cur;\n        }\n        if (\n          onIf === false\n          && pastIf === false\n          && cur.type.typeSymbol === ConditionalSlot.If.typeSymbol\n          ) {\n          onIf = true;\n          if (valid) {\n            break;\n          }\n          continue;\n        }\n        if (cur.type.typeSymbol === ConditionalSlot.ElseIf.typeSymbol) {\n          pastIf = true;\n          if (valid) {\n            break;\n          }\n          continue;\n        }\n        if (cur.type.typeSymbol === ConditionalSlot.Else.typeSymbol) {\n          res = cur;\n          break;\n        }\n      }\n    }\n    if (evalResult) {\n      const prev = scopeObj.excludeSlots([ConditionalSlot as any], true);\n      if (onIf && res !== null && res !== undefined) {\n        return React.cloneElement(createdElement, elProps,\n          ScopeMap.mapElements(prev),\n          res,\n        );\n      }\n      return React.cloneElement(createdElement, elProps,\n        ScopeMap.mapElements(prev),\n      );\n    }\n    if (res !== null && onIf === false) {\n      return React.cloneElement(createdElement, elProps,\n        res,\n      );\n    }\n    return null;\n  }\n  ConditionalSlot.displaySymbol = elDisplay;\n  ConditionalSlot.typeSymbol = typeSymbol;\n  if (parent === undefined) {\n    const If = createDefaultConditionalSlot(React.Fragment, IF, ConditionalSlot);\n    const Else = createDefaultConditionalSlot(React.Fragment, ELSEIF, ConditionalSlot);\n    const ElseIf = createDefaultConditionalSlot(React.Fragment, ELSE, ConditionalSlot);\n    ConditionalSlot.If = If;\n    ConditionalSlot.ElseIf = Else;\n    ConditionalSlot.Else = ElseIf;\n    // @ts-ignore\n    ConditionalSlot.SubSlot = SubSlotFactory(ConditionalSlot);\n  } else {\n    setTimeout(() => {\n      ConditionalSlot.If = parent.If;\n      ConditionalSlot.ElseIf = parent.Else;\n      ConditionalSlot.Else = parent.ElseIf;\n      ConditionalSlot.SubSlot = SubSlotFactory(parent);\n    }, 0);\n  }\n  return ConditionalSlot;\n}\nconst ConditionalSlotElement: IConditionalSlot = createDefaultConditionalSlot();\n\nexport const createConditionalElement: IOverloadCreateConditional = (\n  Element: keyof JSX.IntrinsicElements | React.ComponentType<any>,\n  ) => createDefaultConditionalSlot(Element, IF);\n\nexport {ConditionalSlotElement as default};\n","import useScope from './utils/useScope';\nimport createSlot, {createLayeredSlot} from './utils/createSlot';\nimport ConditionalSlot, {createConditionalElement} from './ConditionalSlot';\nimport createConditionalSlot from './ConditionalSlot//createConditionalSlot';\nimport FilterSlot from './FilterSlot';\nimport CompositionSlot from './CompositionSlot';\n\nexport {\n  CompositionSlot,\n  ConditionalSlot,\n  FilterSlot,\n  createSlot,\n  createSlot as default,\n  createLayeredSlot,\n  createConditionalSlot,\n  createConditionalElement,\n  useScope,\n};\n","import React from 'react';\nimport createSlot, { ISlotComponentBase, IHeaderFooter, SlotType,\n  ISubSlotElement, ISubSlot, ISlotElement, ISlot } from '../utils/createSlot';\nimport {IConditionalSlot, createDefaultConditionalSlot} from '.';\n\ninterface IHeaderFooterConditional extends IHeaderFooter {\n  Conditional: IConditionalSlot;\n}\n\nexport interface ISlotConditional<T> extends ISlotElement<T> {\n  displaySymbol: symbol;\n  Conditional: IConditionalSlot<T & ISlot>;\n}\n\ninterface ISubSlotConditional<T> extends ISubSlotElement<T> {\n  Conditional: React.FC<ISubSlot<T>>;\n}\n\ninterface IHeaderFooterConditional extends IHeaderFooter {\n  Conditional: IConditionalSlot;\n}\n\nexport interface IConditionalSlotComponent<T = any> extends ISlotComponentBase<T> {\n  Slot: ISlotConditional<T>;\n  SubSlot: ISubSlotConditional<T>;\n  Before: IHeaderFooterConditional;\n  After: IHeaderFooterConditional;\n}\ninterface IOverloadCreateConditionalSlot {\n  (Element: keyof JSX.IntrinsicElements | React.ComponentType<any>): IConditionalSlotComponent;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType<any>,\n  ): IConditionalSlotComponent<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(Element?: React.ComponentType<any>): IConditionalSlotComponent<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element?: React.ComponentType<any>,\n  ): IConditionalSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element?: React.ComponentType<any>,\n  ): IConditionalSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n}\nconst ConditionalSubSlotFactory = <T extends {}>(Element: IConditionalSlotComponent): React.FC<ISubSlot<T>> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element.Slot.Conditional {...props} scope={value}/>}</Context.Consumer>;\n};\n\nconst createConditionalSlot: IOverloadCreateConditionalSlot = <T extends {} = {}, S extends {} = {}>(\n  Element: React.ComponentType<any> | keyof JSX.IntrinsicElements = React.Fragment,\n  ) => {\n  type CurType = SlotType<T, S>;\n  const SlottedElement = createSlot(Element) as IConditionalSlotComponent<CurType>;\n  SlottedElement.Slot.Conditional = createDefaultConditionalSlot(\n    SlottedElement.Slot as React.ComponentType<any>) as IConditionalSlot<CurType & ISlot<any>>;\n  SlottedElement.SubSlot.Conditional = ConditionalSubSlotFactory<CurType>(SlottedElement);\n  SlottedElement.Before.Conditional = createDefaultConditionalSlot(SlottedElement.Before as React.ComponentType<any>);\n  SlottedElement.Before.Conditional.displaySymbol = SlottedElement.Before.displaySymbol;\n  SlottedElement.After.Conditional = createDefaultConditionalSlot(SlottedElement.After as React.ComponentType<any>);\n  SlottedElement.After.Conditional.displaySymbol = SlottedElement.After.displaySymbol;\n  return SlottedElement;\n};\n\nexport {createConditionalSlot as default};\n","import * as React from 'react';\nimport { ISortChildrenEl, ISlotComponent } from '../utils/createSlot';\nimport useScope, {TConditionalSlot, ScopeMap } from '../utils/useScope';\n\nexport interface IFilterSlot {\n  /**\n   * Elements or indexed children object passed for filtering\n   */\n  scope: any;\n  /**\n   * Array of slottable components for filtering out\n   */\n  exclude?: TConditionalSlot[];\n  /**\n   * Array of slottable components whitelisted for not being filtered. Overrides 'exclude'\n   */\n  include?: TConditionalSlot[];\n  /**\n   * Filter out all slottable components, overrides include and exclude properties\n   */\n  all?: boolean;\n  /**\n   * Group all elements in order added.\n   */\n  grouped?: boolean;\n}\n\nexport interface IFilterSubSlot extends IFilterSlot {\n  scope: React.Context<any>;\n}\n\ninterface IFilterSlotComponent extends React.FC<IFilterSlot> {\n  SubSlot: React.FunctionComponent<IFilterSubSlot>;\n}\n\nconst FilterSlotFactory = (Element: React.FC<IFilterSlot>): React.FC<IFilterSubSlot> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element {...props} scope={value} />}</Context.Consumer>;\n};\n\nconst isSlotted = (\n  child: any | ISlotComponent,\n  ): child is ISlotComponent => child && child.type && child.type.displaySymbol;\n\ntype TCreateFilterSlot = (Element?: keyof JSX.IntrinsicElements | React.ComponentType<any>) => IFilterSlotComponent;\n\nexport const createFilterSlot: TCreateFilterSlot = (\n  Element = React.Fragment,\n) =>  {\n  const createdElement = React.createElement(Element);\n  const FilterSlot = ({ scope, exclude, include, grouped, all }: IFilterSlot) => {\n    if (grouped === true) {\n      const childrenObject = useScope(scope);\n      let prev = [] as ISortChildrenEl[];\n      if (exclude) {\n        prev = childrenObject.excludeSlots(exclude, all);\n      } else if (include) {\n        prev = childrenObject.includeSlots(include);\n        if (all) {\n          prev.push(...childrenObject.nonSlotted());\n        }\n      }\n      const x = ScopeMap.mapElements(prev);\n      return React.cloneElement(createdElement, {}, x);\n    }\n    let childrenObj = scope;\n    const res: JSX.Element[] = [];\n    if (scope instanceof ScopeMap) {\n      childrenObj = scope.scopeChildren();\n    }\n    const includeSlots = include && ScopeMap.reduceConds(include);\n    const excludeSlots = exclude && ScopeMap.reduceConds(exclude);\n    const filterElement = (child: JSX.Element) => {\n      const checkSlot = (x: TConditionalSlot | undefined, included: boolean) => {\n        if (x === undefined) {\n          return;\n        }\n        if (ScopeMap.isConditionsComponent(x)) {\n          if (x.test(child.props) === included) {\n            return res.push(child);\n          }\n          return;\n        }\n        if (included) {\n          res.push(child);\n        }\n      };\n      if (isSlotted(child)) {\n        if (excludeSlots) {\n          checkSlot(excludeSlots[child.type.displaySymbol as any], false);\n        } else if (includeSlots) {\n          checkSlot(includeSlots[child.type.displaySymbol as any], true);\n        }\n        return;\n      }\n      if (all) {\n        res.push(child);\n      }\n    };\n    const childrenCount = React.Children.count(childrenObj);\n    if (childrenCount === 1) {\n      filterElement(childrenObj);\n    } else if (childrenCount > 1) {\n        React.Children.forEach(childrenObj, filterElement);\n    }\n    return React.cloneElement(createdElement, {}, res);\n  };\n  FilterSlot.SubSlot = FilterSlotFactory(FilterSlot);\n  return FilterSlot;\n};\n\nconst DefaultFilterSlot: IFilterSlotComponent = createFilterSlot();\n\nexport {DefaultFilterSlot as default};\n","import * as React from 'react';\nimport {injectSlot} from '../utils/createSlot';\nimport {ScopeMap} from '../utils/useScope';\nimport { ISlotComponent } from '../utils/createSlot';\n\n/**\n * Allows composition through children.\n */\nexport interface ICompositionSlot {\n  /**\n   * Children with rules on passing (reads props, multiple, )\n   */\n  children?: any;\n  /**\n   * Elements or indexed children object passed for Compositioning\n   */\n  scope: any;\n  /**\n   * Include all non-slottable elements\n   */\n  all?: boolean;\n  /**\n   * [planned] - group by type in order of appearance. Currently not implemented,\n   * but will be if cases are found.\n   */\n  // grouped?: boolean;\n}\n\nconst isSlotted = (\n  child: any | ISlotComponent,\n  ): child is ISlotComponent => child && child.type && child.type.displaySymbol;\n\nexport interface ICompositionSubSlot extends ICompositionSlot {\n  scope: React.Context<any>;\n}\n\ninterface ICompositionSlotComponent<T = {}> extends React.FC<ICompositionSlot & T> {\n  SubSlot: React.FunctionComponent<ICompositionSubSlot>;\n}\n\nconst CompositionSlotFactory = (Element: React.FC<ICompositionSlot>): React.FC<ICompositionSubSlot> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element {...props} scope={value} />}</Context.Consumer>;\n};\n\ninterface IOverloadCreateCompositionSlot {\n  (Element: keyof JSX.IntrinsicElements | React.ComponentType<any>): ICompositionSlotComponent;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType<any>,\n  ): ICompositionSlotComponent<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(Element?: React.ComponentType<any>): ICompositionSlotComponent<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element?: React.ComponentType<any>,\n  ): ICompositionSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element?: React.ComponentType<any>,\n  ): ICompositionSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n}\nconst createCompositionSlot: IOverloadCreateCompositionSlot = (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType<any> = React.Fragment,\n  ) => {\n  const createdElement = React.createElement(Element);\n  const CompositionSlotComponent = ({ scope, all, children }: ICompositionSlot) => {\n    const childrenArr = Array.isArray(children) ? children : [children];\n    const childrenObj = childrenArr.reduce((prev, el) => {\n      if (el.type && el.type.displaySymbol) {\n        if (!prev[el.type.displaySymbol]) {\n          prev[el.type.displaySymbol] = [];\n        }\n        prev[el.type.displaySymbol].push(el);\n      }\n      return prev;\n    },\n    {} as {[name: string]: any[]});\n    const res: JSX.Element[] = [];\n    const filterElement = (child: JSX.Element, key?: number) => {\n      if (isSlotted(child) && child.type && child.type.Slot) {\n        const result = childrenObj[child.type.Slot.displaySymbol];\n        if (result) {\n          for (const El of result) {\n            const slotted = injectSlot(child.type, El.props)(child, key);\n            if (slotted) {\n              res.push(slotted);\n            }\n          }\n        }\n      } else if (all) {\n        res.push(child);\n      }\n    };\n    let scopeObj = scope;\n    if (scope instanceof ScopeMap) {\n      scopeObj = scope.scopeChildren();\n    }\n    const childrenCount = React.Children.count(scopeObj);\n    if (childrenCount === 1) {\n      filterElement(scopeObj);\n    } else if (childrenCount > 1) {\n        React.Children.forEach(scopeObj, filterElement);\n    }\n    return React.cloneElement(createdElement, {}, res);\n  };\n  CompositionSlotComponent.SubSlot = CompositionSlotFactory(CompositionSlotComponent);\n  return CompositionSlotComponent;\n};\n\nconst CompositionSlot: ICompositionSlotComponent = createCompositionSlot();\n\nexport default CompositionSlot;\n"],"sourceRoot":""}