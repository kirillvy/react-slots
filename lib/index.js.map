{"version":3,"sources":["webpack://slottr/webpack/universalModuleDefinition","webpack://slottr/webpack/bootstrap","webpack://slottr/external \"react\"","webpack://slottr/./src/utils/useScope.tsx","webpack://slottr/./src/utils/ScopeUtils.tsx","webpack://slottr/./src/utils/createSlot.tsx","webpack://slottr/./src/ConditionalSlot/index.tsx","webpack://slottr/./src/index.tsx","webpack://slottr/./src/ConditionalSlot/createConditionalSlot.tsx","webpack://slottr/./src/FilterSlot/index.tsx","webpack://slottr/./src/CompositionSlot/index.tsx"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ScopeMap","Map","childrenProp","super","lastIndex","scopeChildren","this","children","injectElement","child","childType","isValidElement","undefined","type","obj","displayName","displaySymbol","resultGet","index","pushLastIndex","set","push","includes","arr","every","evalSlot","includeSlots","reduce","filterSlot","excludeSlots","all","prev","vals","reduceConds","forEach","val","cond","nonSlotted","exclude","el","isConditionsComponent","slot","test","objConditions","filter","elem","props","some","has","mapArr","Array","length","childrenCount","Children","count","default","scope","ScopeUtils","els","sort","a","b","map","entity","prevV","injectSlot","Element","slotProps","defaultElement","defaultProps","passedProps","withContext","childIs","Context","Provider","contextChildren","React","cloneElement","childProps","SlottableElement","Fragment","renderInParam","renderAs","renderIn","renderInProps","createElement","createSlot","SlottedElement","createContext","Before","After","Slot","multiple","fallback","fallbackProps","noHeaders","childrenObj","res","headersList","footersList","headers","footers","element","childObj","result","SlotFactory","SubSlot","Consumer","SubSlotFactory","contextTypes","createLayeredSlot","elDisplay","IF","ELSEIF","ELSE","slotEvalIf","excludes","condition","include","conditional","Boolean","createDefaultConditionalSlot","typeSymbol","parent","ConditionalSlot","elProps","newProps","scopeObj","evalResult","onIf","pastIf","cur","valid","If","ElseIf","Else","mapElements","setTimeout","ConditionalSlotElement","createConditionalElement","useScope","createConditionalSlot","FilterSlot","CompositionSlot","Conditional","ConditionalSubSlotFactory","createFilterSlot","grouped","childrenObject","x","filterElement","checkSlot","included","isSlotted","FilterSlotFactory","DefaultFilterSlot","CompositionSlotComponent","isArray","El","slotted","CompositionSlotFactory","createCompositionSlot"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"slottr\", [\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"slottr\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"slottr\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import React from 'react';\nimport { ISortChildrenEl, ISlotComponent } from './createSlot';\nimport ScopeUtils from './ScopeUtils';\n\n/**\n * Indexes React children for faster access by Slot components\n * @param scope - react children, in any format\n */\n\nexport interface IConditionsComponent {\n  /**\n   * Slottable component for filtering\n   */\n  slot: ISlotComponent<any>;\n  /**\n   * Slottable component test\n   */\n  test: <T = any>(props: T) => boolean;\n}\n\nexport type TConditionalSlot = ISlotComponent<any> | IConditionsComponent;\n\n/**\n * Scope object. Slottable elements are tracked as Element.DisplaySymbol\n * Custom components as Element.DisplayName.\n */\nexport class ScopeMap extends Map<symbol | string, ISortChildrenEl[]> {\n  private lastIndex = -1;\n  private children: any;\n  constructor(childrenProp?: any) {\n    super();\n    if (!childrenProp) {\n      return;\n    }\n    const mapArr = (arr: any[]) => arr.reduce((prev, el) => {\n        if (el instanceof Array && el.length) {\n          prev.push(...mapArr(el));\n        } else {\n          prev.push(el);\n        }\n        return prev;\n      },\n      [] as any[]);\n    this.children = mapArr([childrenProp]);\n    const childrenCount = React.Children.count(this.children);\n    if (childrenCount === 1) {\n      this.injectElement(this.children);\n    } else if (childrenCount > 1) {\n        React.Children.forEach(childrenProp, this.injectElement);\n    }\n  }\n  /**\n   * Injects element into the scope\n   * @param child JSX element to inject\n   */\n  public scopeChildren = () => this.children;\n  public injectElement = (child: JSX.Element) => {\n    let childType = 'string';\n    if (React.isValidElement(child) && child.type !== undefined) {\n      const obj: any = child.type;\n      if (obj.hasOwnProperty('displayName')) {\n        childType = obj.displayName || 'string';\n      } else {\n        childType = obj;\n      }\n      if (obj.hasOwnProperty('displaySymbol')) {\n        childType = obj.displaySymbol;\n      }\n    }\n    const resultGet = this.get(childType);\n    const index = this.pushLastIndex();\n    if (resultGet === undefined) {\n      this.set(childType, [{index, child}]);\n    } else {\n      resultGet.push({index, child});\n      this.set(childType, resultGet);\n    }\n  }\n  /**\n   * Tests whether object includes all conditional slots\n   * @param arr conditional slots for inclusion\n   */\n  public includes = (...arr: TConditionalSlot[]) => {\n    return arr.every(this.evalSlot(true));\n  }\n  /**\n   * Tests whether object excludes all conditional slots\n   * @param arr conditional slots for exclusion\n   */\n  public excludes(...arr: TConditionalSlot[]) {\n    return !arr.some(this.evalSlot());\n  }\n  /**\n   * Returns array of conditional slots included\n   * @param arr conditional slots for inclusion\n   */\n  public includeSlots = (arr: TConditionalSlot[]) => {\n    return arr.reduce(this.filterSlot(), [] as ISortChildrenEl[]);\n  }\n  /**\n   * Returns array of conditional slots without the excluded ones\n   * @param arr conditional slots for exclusion\n   * @param all include all elements including non-conditional slots\n   */\n  public excludeSlots = (arr: TConditionalSlot[], all?: boolean) => {\n    const prev: ISortChildrenEl[] = [];\n    const vals = ScopeUtils.reduceConds(arr);\n    this.forEach((val, key) => {\n      if (typeof key !== 'symbol' && all !== true) {\n        return;\n      }\n      const cond = vals[key as any];\n      if (cond) {\n        this.filterSlot(true)(prev, cond);\n      } else {\n        prev.push(...val);\n      }\n    });\n    return prev;\n  }\n  /**\n   * Returns all non-slot elements in scope\n   */\n  public nonSlotted = () => {\n    const prev: ISortChildrenEl[] = [];\n    this.forEach((val, key) => {\n      if (typeof key !== 'symbol') {\n        prev.push(...val);\n      }\n    });\n    return prev;\n  }\n  /**\n   * controls index on insert\n   */\n  private pushLastIndex = () => {\n    this.lastIndex += 1;\n    return this.lastIndex;\n  }\n  /**\n   * filters slots by params\n   */\n  private filterSlot = (exclude?: boolean) => (prev: ISortChildrenEl[], el: TConditionalSlot) => {\n    if (ScopeUtils.isConditionsComponent(el)) {\n      const { slot, test } = el;\n      const objConditions = this.get(slot.displaySymbol);\n      if (objConditions !== undefined) {\n        if (exclude) {\n          prev.push(...objConditions.filter((elem) => !test(elem.child.props)));\n        } else {\n          prev.push(...objConditions.filter((elem) => test(elem.child.props)));\n        }\n      }\n      return prev;\n    }\n    const obj = this.get(el.displaySymbol);\n    if (obj !== undefined && exclude !== true) {\n      prev.push(...obj);\n    }\n    return prev;\n  }\n  /**\n   * evals slots by params\n   */\n  private evalSlot = (includes?: boolean) => (el: TConditionalSlot) => {\n    if (ScopeUtils.isConditionsComponent(el)) {\n      const {slot, test} = el;\n      const obj = this.get(slot.displaySymbol);\n      if (includes) {\n        return obj !== undefined && obj.every((elem) => test(elem.child.props)) === true;\n      }\n      return obj !== undefined && obj.some((elem) => test(elem.child.props)) === true;\n    }\n    return this.has(el.displaySymbol);\n  }\n}\n/**\n * Creates scope object for work with slots\n * @param scope - React Children prop\n */\nconst useScope = (scope: any): ScopeMap => {\n  if (scope instanceof ScopeMap) {\n    return scope;\n  }\n  if (scope === undefined || scope.length === 0) {\n    return new ScopeMap();\n  }\n  const result = new ScopeMap(scope);\n  return result;\n};\n\nexport {useScope as default};\n","import { ISortChildrenEl, ISlotComponent } from './createSlot';\nimport {IConditionsComponent, TConditionalSlot} from './useScope';\n\nexport class ScopeUtils {\n  public static isConditionsComponent = (\n    entity: ISlotComponent<any> | IConditionsComponent,\n    ): entity is IConditionsComponent => {\n    return (entity as IConditionsComponent).test !== undefined;\n  }\n  /**\n   * Reduces conditions to an object.\n   */\n  public static reduceConds = (arr: TConditionalSlot[]) => arr.reduce((prevV, val) => {\n    const key = ScopeUtils.isConditionsComponent(val) ? val.slot.displaySymbol : val.displaySymbol as any;\n    prevV[key] = val;\n    return prevV;\n  }, {} as { [x: string]: TConditionalSlot })\n\n  /**\n   * Sorts elements by order of appearance\n   * @param els children object to sort into children\n   */\n  public static sortElements(els: ISortChildrenEl[]): JSX.Element[] {\n    return els.sort((a, b) => a.index - b.index).map((el) => el.child);\n  }\n  /**\n   * Returns grouped elements, by order of appearance\n   * @param els children object to sort into children\n   */\n  public static mapElements(els: ISortChildrenEl[]): JSX.Element[] {\n    return els.map((el) => el.child);\n  }\n}\n\nexport {ScopeUtils as default};\n","import * as React from 'react';\n\nimport useScope from './useScope';\n\nexport interface ISlot<T = any> {\n  /**\n   * Default children of element, if any. Otherwise, nothing will be shown.\n   */\n  children?: any;\n  /**\n   * Props that will always be rendered, no matter the scenario\n   */\n  props?: T;\n  /**\n   * default props to use when the default element is rendered\n   */\n  defaultProps?: JSX.IntrinsicAttributes & React.PropsWithChildren<T>;\n  /**\n   * props passed to the element from the component containing the slot\n   */\n  passedProps?: T;\n  /**\n   * Elements or indexed children object passed for filtering\n   */\n  scope?: any;\n  /**\n   * Slottable component test\n   */\n  test?: <S = any>(props: S) => boolean;\n  /**\n   * Display all if multiple slots are passed\n   */\n  multiple?: boolean;\n  /**\n   * Components are composed through their immediate children instead of\n   * children of element\n   */\n  withContext?: boolean;\n  /**\n   * fallback to use if slot is not used\n   */\n  fallback?: any;\n  /**\n   * default props to use with default element\n   */\n  fallbackProps?: JSX.IntrinsicAttributes & React.PropsWithChildren<T>;\n  /**\n   * Designate the children prop as the default element, the fallback element or both\n   */\n  childIs?: 'fallback' | 'default' | 'both';\n  /**\n   * Component is always rendered.\n   */\n  unconditional?: boolean;\n  noHeaders?: boolean;\n}\n\ntype TAny = any;\ntype ElType<T> = ISlotComponent<T> | ISlotComponentExtended<T>;\n\ninterface IRenderAs extends TAny {\n  renderIn?: React.ComponentType | keyof JSX.IntrinsicElements | false;\n  /**\n   * Props passed into next level component\n   */\n  renderInProps?: any;\n  /**\n   * Element injected for rendering instead of default. Any props will have to be compatible.\n   */\n  renderAs?: React.ComponentType | keyof JSX.IntrinsicElements;\n}\n\nexport interface ISubSlot<T> extends Partial<ISlot<T>> {\n  scope: React.Context<any>;\n}\n\nexport interface ISlotElement<T> extends React.FunctionComponent<ISlot<T>> {\n  displaySymbol: symbol;\n}\n\nexport interface ISubSlotElement<T> extends React.FunctionComponent<ISubSlot<T>> {\n  displaySymbol: symbol;\n}\n\nexport interface ISlotComponentBase<T = any> extends React.FunctionComponent<T | IRenderAs | {children?: any}> {\n  Context: React.Context<any>;\n  displaySymbol: symbol;\n}\n\nexport interface ISlotComponent<T = any> extends ISlotComponentBase<T> {\n  Slot: ISlotElement<T>;\n  SubSlot: ISubSlotElement<T>;\n  Before: IHeaderFooter;\n  After: IHeaderFooter;\n}\n\nexport interface ISlotElementExtended<T> extends ISlotComponent<ISlot<T>> {\n  displaySymbol: symbol;\n}\n\nexport interface ISlotComponentExtended<T = any> extends ISlotComponentBase<T> {\n  Slot: ISlotElementExtended<T>;\n  SubSlot: ISubSlotElement<T>;\n  Before: IHeaderFooter;\n  After: IHeaderFooter;\n}\n\ninterface IOverloadCreateSlot {\n  (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType,\n    renderIn?: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponent;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType,\n    renderIn?: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponent<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(\n    Element?: React.ComponentType,\n    renderIn?: React.ComponentType | keyof JSX.IntrinsicElements,\n    ): ISlotComponent<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element?: React.ComponentType,\n    renderIn?: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element?: React.ComponentType,\n    renderIn?: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n}\n\ninterface IOverloadCreateLayeredSlot {\n  (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType,\n    renderIn: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType,\n    renderIn: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(\n    Element: React.ComponentType,\n    renderIn: React.ComponentType | keyof JSX.IntrinsicElements,\n    ): ISlotComponentExtended<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element: React.ComponentType,\n    renderIn: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element: React.ComponentType,\n    renderIn: React.ComponentType | keyof JSX.IntrinsicElements,\n  ): ISlotComponentExtended<T & Partial<JSX.IntrinsicElements[S]>>;\n}\n\nexport interface IHeaderFooter extends React.FunctionComponent {\n  displaySymbol: symbol;\n  typeSymbol: symbol;\n}\n\nexport interface ISortChildrenEl {\n  index: number;\n  child: JSX.Element;\n}\n\nexport type SlotType<T = {}, S = {}> =\n  T extends {} ? S extends keyof JSX.IntrinsicElements ? T & Partial<JSX.IntrinsicElements[S]> : T :\n  T extends keyof JSX.IntrinsicElements ? S extends {} ? S & Partial<JSX.IntrinsicElements[T]> :\n   Partial<JSX.IntrinsicElements[T]> : any;\n\nexport const injectSlot = <T extends {}>(\n  Element: ElType<T>, slotProps: ISlot<T>,\n  ) => (child: JSX.Element, i?: number) => {\n  const { children: defaultElement, defaultProps, passedProps, withContext, props, childIs } = slotProps;\n  if (withContext === true  && defaultElement !== undefined) {\n    if (childIs === 'fallback') {\n      return null;\n    }\n    if (Element.Context.Provider === undefined) {\n      return null;\n    }\n    const contextChildren = React.cloneElement(child, {...props, ...passedProps });\n    return React.cloneElement(child, { key: i, ...props, ...passedProps }, (\n    <Element.Context.Provider\n      key={i}\n      value={useScope(contextChildren.props.children)}\n    >\n    {defaultElement}\n    </Element.Context.Provider>\n    ));\n  }\n  const childProps: any = child.props;\n  if (child.props === undefined) {\n    return child;\n  }\n  if (childProps.hasOwnProperty('children')) {\n    return React.cloneElement(child, { key: i, ...props, ...passedProps });\n  }\n  return React.cloneElement(child, { key: i, ...props, ...defaultProps, ...passedProps }, defaultElement);\n};\n\nconst SlotFactory = <T extends {}>(\n  Element: ElType<T>,\n  ): React.FC<ISlot<T>> => (\n  slotProps,\n) => {\n  const { scope, children: defaultElement, multiple = false,\n    fallback, fallbackProps, childIs, test, noHeaders } = slotProps;\n  const childrenObj = useScope(scope);\n  const res = childrenObj.get(Element.displaySymbol);\n  const headersList = childrenObj.get(Element.Before.displaySymbol) || [];\n  const footersList = childrenObj.get(Element.After.displaySymbol) || [];\n  const headers = headersList.map((el) => el.child);\n  const footers = footersList.map((el) => el.child);\n  if (res === undefined) {\n    if ((childIs === 'fallback' || childIs === 'both') && defaultElement !== undefined) {\n      return React.cloneElement(defaultElement, fallbackProps);\n    }\n    if (fallback !== undefined) {\n      return React.cloneElement(fallback, fallbackProps);\n    }\n    return <>{headers}{footers}</>;\n  }\n  if (multiple === true) {\n    let element = res.reduce((prev, {index, child}) => {\n      const el = injectSlot(Element, slotProps)(child, index);\n      if (el !== null) {\n        prev.push(el);\n      }\n      return prev;\n    }, [] as Array<React.FunctionComponentElement<any>>);\n    if (test !== undefined) {\n      element = element.filter((el) => test(el.props));\n    }\n    return <>{headers}{element}{footers}</>;\n  }\n  const { child: childObj } = res[0];\n  const result = injectSlot(Element, slotProps)(childObj);\n  if (noHeaders && result === null) {\n    return result;\n  }\n  return <>{headers}{result}{footers}</>;\n};\n\nconst SubSlotFactory = <T extends {}>(Element: ElType<T>): React.FC<ISubSlot<T>> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element.Slot {...props} scope={value}/>}</Context.Consumer>;\n};\n\nconst SlottableElement: (\n    defaultElement?: React.ComponentType | keyof JSX.IntrinsicElements,\n    renderInParam?: React.ComponentType | keyof JSX.IntrinsicElements,\n  ) => React.FC<IRenderAs> = (defaultElement = React.Fragment, renderInParam) => (\n  {children, renderAs, renderIn, renderInProps, ...props},\n  ) => {\n    const el = React.createElement(renderAs || defaultElement, props, children);\n    if (renderInParam && renderIn !== false) {\n      return React.createElement(renderInParam, renderInProps, el);\n    }\n    if (renderIn) {\n      return React.createElement(renderIn, renderInProps, el);\n    }\n    return el;\n  };\n\n/**\n * Slot constructor\n * @param {React.ComponentType<any>} [Element=React.Fragment] - Element for slotting, default is fragment\n */\nconst createSlot: IOverloadCreateSlot = <T extends {} = {}, S extends {} = {}>(\n  Element: React.ComponentType | keyof JSX.IntrinsicElements = React.Fragment,\n  renderIn?: React.ComponentType | keyof JSX.IntrinsicElements,\n  ) => {\n    type CurType = SlotType<T, S>;\n    const SlottedElement = SlottableElement(Element, renderIn) as ISlotComponent<CurType>;\n    SlottedElement.Context = React.createContext(null);\n    SlottedElement.displaySymbol = Symbol();\n    SlottedElement.Before = SlottableElement() as IHeaderFooter;\n    SlottedElement.Before.displaySymbol = Symbol();\n    SlottedElement.After = SlottableElement() as IHeaderFooter;\n    SlottedElement.After.displaySymbol = Symbol();\n    SlottedElement.Slot = SlotFactory<CurType>(SlottedElement) as any;\n    SlottedElement.Slot.displaySymbol = Symbol();\n    SlottedElement.SubSlot = SubSlotFactory<CurType>(SlottedElement) as ISubSlotElement<CurType>;\n    SlottedElement.SubSlot.displaySymbol = Symbol();\n    if (typeof Element !== 'string') {\n      SlottedElement.defaultProps = Element.defaultProps;\n      SlottedElement.contextTypes = Element.contextTypes;\n    }\n    SlottedElement.Slot.displayName = 'Subcomponent.Slot';\n    SlottedElement.displayName = `Subcomponent.SlottedElement`;\n    SlottedElement.SubSlot.displayName = 'Subcomponent.SubSlot';\n    return SlottedElement;\n};\n\nexport const createLayeredSlot: IOverloadCreateLayeredSlot = <T extends {} = {}, S extends {} = {}>(\n  Element: React.ComponentType | keyof JSX.IntrinsicElements = React.Fragment,\n  renderIn: React.ComponentType | keyof JSX.IntrinsicElements,\n  ) => {\n    type CurType = SlotType<T, S>;\n    const SlottedElement = createSlot(Element, renderIn) as ISlotComponentExtended<CurType>;\n    SlottedElement.Slot = createSlot(SlottedElement.Slot);\n    return SlottedElement;\n};\n\nexport {createSlot as default};\n","import React from 'react';\nimport useScope, { TConditionalSlot } from '../utils/useScope';\nimport ScopeUtils from '../utils/ScopeUtils';\n\nexport interface IConditionalSlotBase {\n  children?: any;\n  /**\n   * Elements or indexed children object passed for filtering\n   */\n  scope?: any;\n  /**\n   * Array of slottable components for filtering out\n   */\n  excludes?: TConditionalSlot[];\n  /**\n   * Array of slottable components whitelisted for not being filtered. Overrides 'exclude'\n   */\n  includes?: TConditionalSlot[];\n  /**\n   * Truthy eval of conditions for implementations.\n   */\n  condition?: any;\n}\n\nexport interface IConditionalSubSlot extends IConditionalSlotBase {\n  scope: React.Context<any>;\n}\n\ninterface IOverloadCreateConditional {\n  (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType,\n  ): IConditionalSlot;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType,\n  ): IConditionalSlot<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(Element: React.ComponentType): IConditionalSlot<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element: React.ComponentType,\n  ): IConditionalSlot<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element: React.ComponentType,\n  ): IConditionalSlot<T & Partial<JSX.IntrinsicElements[S]>>;\n}\n\nexport interface IConditionalSlot<T = {}> extends React.FC<IConditionalSlotBase & T> {\n  If: IConditionalSlot;\n  ElseIf: IConditionalSlot;\n  Else: IConditionalSlot;\n  SubSlot: React.FC<IConditionalSubSlot & T>;\n  displaySymbol: symbol;\n  typeSymbol: symbol;\n}\n\nconst SubSlotFactory = <T extends {}>(\n  Element: IConditionalSlot,\n  ): React.FC<IConditionalSubSlot & T> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element {...props} scope={value}/>}</Context.Consumer>;\n};\n\nconst elDisplay = Symbol();\nconst IF = Symbol();\nconst ELSEIF = Symbol();\nconst ELSE = Symbol();\n\nconst slotEvalIf = ({scope, excludes, includes, condition}: IConditionalSlotBase) => {\n  const childrenObj = useScope(scope);\n  const include = (scope && includes) ? childrenObj.includes(...includes) : true;\n  const exclude = (scope && excludes) ? childrenObj.excludes(...excludes) : true;\n  const conditional = condition !== undefined ? Boolean(condition) : true;\n  return include && exclude && conditional;\n};\n\nexport function createDefaultConditionalSlot(\n  Element: keyof JSX.IntrinsicElements | React.ComponentType = React.Fragment,\n  typeSymbol: symbol = IF,\n  parent?: IConditionalSlot,\n  ): IConditionalSlot {\n  function ConditionalSlot(props: IConditionalSlotBase) {\n    const {children, scope, excludes, includes, condition, ...newProps} = props;\n    const elProps = Element === React.Fragment ? {} : {scope, ...newProps};\n    const scopeObj = useScope(children);\n    const evalResult = parent === undefined ? slotEvalIf({scope, excludes, includes, condition}) : true;\n    const obj = scopeObj.get(ConditionalSlot.displaySymbol);\n    let res: React.ReactNode = null;\n    let [onIf, pastIf] = [false, false];\n    if (obj !== undefined) {\n      for (let i = 0; i < obj.length; i++) {\n        const cur: any = obj[i].child;\n        const valid = slotEvalIf(cur.props);\n        if (valid) {\n          res = cur;\n        }\n        if (\n          onIf === false\n          && pastIf === false\n          && cur.type.typeSymbol === ConditionalSlot.If.typeSymbol\n          ) {\n          onIf = true;\n          if (valid) {\n            break;\n          }\n          continue;\n        }\n        if (cur.type.typeSymbol === ConditionalSlot.ElseIf.typeSymbol) {\n          pastIf = true;\n          if (valid) {\n            break;\n          }\n          continue;\n        }\n        if (cur.type.typeSymbol === ConditionalSlot.Else.typeSymbol) {\n          res = cur;\n          break;\n        }\n      }\n    }\n    if (evalResult) {\n      const prev = scopeObj.excludeSlots([ConditionalSlot as any], true);\n      if (onIf && res !== null && res !== undefined) {\n        return React.createElement(Element, elProps,\n          ScopeUtils.mapElements(prev),\n          res,\n        );\n      }\n      return React.createElement(Element, elProps,\n        ScopeUtils.mapElements(prev),\n      );\n    }\n    if (res !== null && onIf === false) {\n      return React.createElement(Element, elProps,\n        res,\n      );\n    }\n    return null;\n  }\n  ConditionalSlot.displaySymbol = elDisplay;\n  ConditionalSlot.typeSymbol = typeSymbol;\n  if (parent === undefined) {\n    const If = createDefaultConditionalSlot(React.Fragment, IF, ConditionalSlot);\n    const Else = createDefaultConditionalSlot(React.Fragment, ELSEIF, ConditionalSlot);\n    const ElseIf = createDefaultConditionalSlot(React.Fragment, ELSE, ConditionalSlot);\n    ConditionalSlot.If = If;\n    ConditionalSlot.ElseIf = Else;\n    ConditionalSlot.Else = ElseIf;\n    // @ts-ignore\n    ConditionalSlot.SubSlot = SubSlotFactory(ConditionalSlot);\n  } else {\n    setTimeout(() => {\n      ConditionalSlot.If = parent.If;\n      ConditionalSlot.ElseIf = parent.Else;\n      ConditionalSlot.Else = parent.ElseIf;\n      ConditionalSlot.SubSlot = SubSlotFactory(parent);\n    }, 0);\n  }\n  return ConditionalSlot;\n}\n\nconst ConditionalSlotElement: IConditionalSlot = createDefaultConditionalSlot();\n\nexport const createConditionalElement: IOverloadCreateConditional = (\n  Element: keyof JSX.IntrinsicElements | React.ComponentType,\n  ) => createDefaultConditionalSlot(Element, IF);\n\nexport {ConditionalSlotElement as default};\n","import useScope from './utils/useScope';\nimport createSlot, {createLayeredSlot} from './utils/createSlot';\nimport createConditionalSlot from './ConditionalSlot/createConditionalSlot';\nimport ConditionalSlot, {createConditionalElement} from './ConditionalSlot';\nimport FilterSlot from './FilterSlot';\nimport CompositionSlot from './CompositionSlot';\n\nexport {\n  CompositionSlot,\n  ConditionalSlot,\n  FilterSlot,\n  createSlot,\n  createSlot as default,\n  createLayeredSlot,\n  createConditionalSlot,\n  createConditionalElement,\n  useScope,\n};\n","import React from 'react';\nimport createSlot, { ISlotComponentBase, IHeaderFooter, SlotType,\n  ISubSlotElement, ISubSlot, ISlotElement, ISlot } from '../utils/createSlot';\nimport {IConditionalSlot, createDefaultConditionalSlot} from '.';\n\ninterface IHeaderFooterConditional extends IHeaderFooter {\n  Conditional: IConditionalSlot;\n}\n\nexport interface ISlotConditional<T> extends ISlotElement<T> {\n  displaySymbol: symbol;\n  Conditional: IConditionalSlot<T & ISlot>;\n}\n\ninterface ISubSlotConditional<T> extends ISubSlotElement<T> {\n  Conditional: React.FC<ISubSlot<T>>;\n}\n\ninterface IHeaderFooterConditional extends IHeaderFooter {\n  Conditional: IConditionalSlot;\n}\n\nexport interface IConditionalSlotComponent<T = any> extends ISlotComponentBase<T> {\n  Slot: ISlotConditional<T>;\n  SubSlot: ISubSlotConditional<T>;\n  Before: IHeaderFooterConditional;\n  After: IHeaderFooterConditional;\n}\ninterface IOverloadCreateConditionalSlot {\n  (Element: keyof JSX.IntrinsicElements | React.ComponentType): IConditionalSlotComponent;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType,\n  ): IConditionalSlotComponent<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(Element?: React.ComponentType): IConditionalSlotComponent<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element?: React.ComponentType,\n  ): IConditionalSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element?: React.ComponentType,\n  ): IConditionalSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n}\nconst ConditionalSubSlotFactory = <T extends {}>(Element: IConditionalSlotComponent): React.FC<ISubSlot<T>> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element.Slot.Conditional {...props} scope={value}/>}</Context.Consumer>;\n};\n\nconst createConditionalSlot: IOverloadCreateConditionalSlot = <T extends {} = {}, S extends {} = {}>(\n  Element: React.ComponentType | keyof JSX.IntrinsicElements = React.Fragment,\n  ) => {\n  type CurType = SlotType<T, S>;\n  const SlottedElement = createSlot(Element) as IConditionalSlotComponent<CurType>;\n  SlottedElement.Slot.Conditional = createDefaultConditionalSlot(\n    SlottedElement.Slot as React.ComponentType) as IConditionalSlot<CurType & ISlot<any>>;\n  SlottedElement.SubSlot.Conditional = ConditionalSubSlotFactory<CurType>(SlottedElement);\n  SlottedElement.Before.Conditional = createDefaultConditionalSlot(SlottedElement.Before as React.ComponentType);\n  SlottedElement.Before.Conditional.displaySymbol = SlottedElement.Before.displaySymbol;\n  SlottedElement.After.Conditional = createDefaultConditionalSlot(SlottedElement.After as React.ComponentType);\n  SlottedElement.After.Conditional.displaySymbol = SlottedElement.After.displaySymbol;\n  return SlottedElement;\n};\n\nexport {createConditionalSlot as default};\n","import * as React from 'react';\nimport { ISortChildrenEl, ISlotComponent } from '../utils/createSlot';\nimport useScope, {TConditionalSlot, ScopeMap } from '../utils/useScope';\nimport ScopeUtils from '../utils/ScopeUtils';\n\nexport interface IFilterSlot {\n  /**\n   * Elements or indexed children object passed for filtering\n   */\n  scope: any;\n  /**\n   * Array of slottable components for filtering out\n   */\n  exclude?: TConditionalSlot[];\n  /**\n   * Array of slottable components whitelisted for not being filtered. Overrides 'exclude'\n   */\n  include?: TConditionalSlot[];\n  /**\n   * Filter out all slottable components, overrides include and exclude properties\n   */\n  all?: boolean;\n  /**\n   * Group all elements in order added.\n   */\n  grouped?: boolean;\n}\n\nexport interface IFilterSubSlot extends IFilterSlot {\n  scope: React.Context<any>;\n}\n\ninterface IFilterSlotComponent extends React.FC<IFilterSlot> {\n  SubSlot: React.FunctionComponent<IFilterSubSlot>;\n}\n\nconst FilterSlotFactory = (Element: React.FC<IFilterSlot>): React.FC<IFilterSubSlot> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element {...props} scope={value} />}</Context.Consumer>;\n};\n\nconst isSlotted = (\n  child: any | ISlotComponent,\n  ): child is ISlotComponent => child && child.type && child.type.displaySymbol;\n\nexport const createFilterSlot = (\n  Element: keyof JSX.IntrinsicElements | React.ComponentType = React.Fragment,\n) =>  {\n  const FilterSlot = ({ scope, exclude, include, grouped, all }: IFilterSlot) => {\n    if (grouped === true) {\n      const childrenObject = useScope(scope);\n      let prev = [] as ISortChildrenEl[];\n      if (exclude) {\n        prev = childrenObject.excludeSlots(exclude, all);\n      } else if (include) {\n        prev = childrenObject.includeSlots(include);\n        if (all) {\n          prev.push(...childrenObject.nonSlotted());\n        }\n      }\n      const x = ScopeUtils.mapElements(prev);\n      return React.createElement(Element, {}, x);\n    }\n    let childrenObj = scope;\n    const res: JSX.Element[] = [];\n    if (scope instanceof ScopeMap) {\n      childrenObj = scope.scopeChildren();\n    }\n    const includeSlots = include && ScopeUtils.reduceConds(include);\n    const excludeSlots = exclude && ScopeUtils.reduceConds(exclude);\n    const filterElement = (child: JSX.Element) => {\n      const checkSlot = (x: TConditionalSlot | undefined, included: boolean) => {\n        if (x === undefined) {\n          return;\n        }\n        if (ScopeUtils.isConditionsComponent(x)) {\n          if (x.test(child.props) === included) {\n            return res.push(child);\n          }\n          return;\n        }\n        if (included) {\n          res.push(child);\n        }\n      };\n      if (isSlotted(child)) {\n        if (excludeSlots) {\n          checkSlot(excludeSlots[child.type.displaySymbol as any], false);\n        } else if (includeSlots) {\n          checkSlot(includeSlots[child.type.displaySymbol as any], true);\n        }\n        return;\n      }\n      if (all) {\n        res.push(child);\n      }\n    };\n    const childrenCount = React.Children.count(childrenObj);\n    if (childrenCount === 1) {\n      filterElement(childrenObj);\n    } else if (childrenCount > 1) {\n        React.Children.forEach(childrenObj, filterElement);\n    }\n    return React.createElement(Element, {}, res);\n  };\n  FilterSlot.SubSlot = FilterSlotFactory(FilterSlot);\n  return FilterSlot;\n};\n\nconst DefaultFilterSlot: IFilterSlotComponent = createFilterSlot();\n\nexport {DefaultFilterSlot as default};\n","import * as React from 'react';\nimport {injectSlot} from '../utils/createSlot';\nimport {ScopeMap} from '../utils/useScope';\nimport { ISlotComponent } from '../utils/createSlot';\n\n/**\n * Allows composition through children.\n */\nexport interface ICompositionSlot {\n  /**\n   * Children with rules on passing (reads props, multiple, )\n   */\n  children?: any;\n  /**\n   * Elements or indexed children object passed for Compositioning\n   */\n  scope: any;\n  /**\n   * Include all non-slottable elements\n   */\n  all?: boolean;\n  /**\n   * [planned] - group by type in order of appearance. Currently not implemented,\n   * but will be if cases are found.\n   */\n  // grouped?: boolean;\n}\n\nconst isSlotted = (\n  child: any | ISlotComponent,\n  ): child is ISlotComponent => child && child.type && child.type.displaySymbol;\n\nexport interface ICompositionSubSlot extends ICompositionSlot {\n  scope: React.Context<any>;\n}\n\ninterface ICompositionSlotComponent<T = {}> extends React.FC<ICompositionSlot & T> {\n  SubSlot: React.FunctionComponent<ICompositionSubSlot>;\n}\n\nconst CompositionSlotFactory = (Element: React.FC<ICompositionSlot>): React.FC<ICompositionSubSlot> => (\n  { scope: Context, ...props },\n) => {\n  return <Context.Consumer>{(value) => <Element {...props} scope={value} />}</Context.Consumer>;\n};\n\ninterface IOverloadCreateConditionalSlot {\n  (Element: keyof JSX.IntrinsicElements | React.ComponentType): ICompositionSlotComponent;\n  <T extends keyof JSX.IntrinsicElements>(\n    Element: T | React.ComponentType,\n  ): ICompositionSlotComponent<Partial<JSX.IntrinsicElements[T]>>;\n  <T extends {}>(Element?: React.ComponentType): ICompositionSlotComponent<T>;\n  <S extends keyof JSX.IntrinsicElements, T extends {}>(\n    Element?: React.ComponentType,\n  ): ICompositionSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n  <T extends {}, S extends keyof JSX.IntrinsicElements>(\n    Element?: React.ComponentType,\n  ): ICompositionSlotComponent<T & Partial<JSX.IntrinsicElements[S]>>;\n}\nconst createCompositionSlot: IOverloadCreateConditionalSlot = (\n    Element: keyof JSX.IntrinsicElements | React.ComponentType = React.Fragment,\n  ) => {\n  const CompositionSlotComponent = ({ scope, all, children }: ICompositionSlot) => {\n    const childrenArr = Array.isArray(children) ? children : [children];\n    const childrenObj = childrenArr.reduce((prev, el) => {\n      if (el.type && el.type.displaySymbol) {\n        if (!prev[el.type.displaySymbol]) {\n          prev[el.type.displaySymbol] = [];\n        }\n        prev[el.type.displaySymbol].push(el);\n      }\n      return prev;\n    },\n    {} as {[name: string]: any[]});\n    const res: JSX.Element[] = [];\n    const filterElement = (child: JSX.Element, key?: number) => {\n      if (isSlotted(child) && child.type && child.type.Slot) {\n        const result = childrenObj[child.type.Slot.displaySymbol];\n        if (result) {\n          for (let i = 0; i < result.length; i++) {\n            const El = result[i];\n            const slotted = injectSlot(child.type, El.props)(child, key);\n            if (slotted) {\n              res.push(slotted);\n            }\n          }\n        }\n      } else if (all) {\n        res.push(child);\n      }\n    };\n    let scopeObj = scope;\n    if (scope instanceof ScopeMap) {\n      scopeObj = scope.scopeChildren();\n    }\n    const childrenCount = React.Children.count(scopeObj);\n    if (childrenCount === 1) {\n      filterElement(scopeObj);\n    } else if (childrenCount > 1) {\n        React.Children.forEach(scopeObj, filterElement);\n    }\n    return React.createElement(Element, {}, res);\n  };\n  CompositionSlotComponent.SubSlot = CompositionSlotFactory(CompositionSlotComponent);\n  return CompositionSlotComponent;\n};\n\nconst CompositionSlot: ICompositionSlotComponent = createCompositionSlot();\n\nexport default CompositionSlot;\n"],"sourceRoot":""}